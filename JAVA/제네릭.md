# 제네릭

## 제네릭 클래스와 인터페이스
자바에서는 클래스와 인터페이스를 내부 멤버에서 활용하는 클래스를 작성하고자 할 때, 
제공되는 클래스나 인터페이스의 다양성 만큼 많은 가짓수의 클래스를 생성해야 한다.

또한, 동일한 이름의 메서드가 다양한 타입의 매개변수를 가질 수 있도록 하기 위해, 고려하는 매개변수 타입의 수만큼 오버로딩을 해야한다.

이런 비효율성을 해결하는데 필요한 문법 요소가 **'제네릭'** 이다.

### 제네릭 없이 여러 객체(배우와 아이돌)를 저장하는 굿즈(Goods) 클래스 작성해보기
클래스 ActorGoods 와 IdolGoods 필드가 Actor 또는 Idol 타입이라는 것을 제외하면 동일하다.   
즉, 배우와 아이돌을 저장하고 관리하기 위해 각각의 동일한 기능을 수행하는 굿즈(Goods) 클래스를 2개 만든 셈이다.

```java
class Actor {

}

class Idol {

}

// 배우만 저장할 수 있는 굿즈 클래스
class ActorGoods {
    private Actor actor = new Actor();

    public Actor getActor() {
        return actor;
    }

    public void setActor(Actor actor) {
        this.actor = actor;
    }
}

// 아이돌만 저장할 수 있는 굿즈 클래스
class IdolGoods {
    private Idol idol = new Idol();

    public Idol getIdol() {
        return idol;
    }

    public void setIdol(Idol idol) {
        this.idol = idol;
    }
}

public class Main {
    public static void main(String[] args) {
        // 배우 저장(set)하고 가져(get)오기
        ActorGoods actorGoods = new ActorGoods();
        actorGoods.setActor(new Actor());
        Actor actor = actorGoods.getActor();

        // 아이돌 저장하고 가져오기
        IdolGoods idolGoods = new IdolGoods();
        idolGoods.setIdol(new Idol());
        Idol idol = idolGoods.getIdol();
    }
}
```
위와 같이 설계를 한다면, 새로운 상품이 추가될 떄마다 ActorGoods, IdolGoods 과 같은 클래스를 생성해야는 문제가 발생한다.   

### # 문제 정의 : 1개의 굿즈 클래스로 모든 타입의 상품을 저장하고 관리할 수는 없을까??

### 해결 ① 필드타입을 모든 객체를 저장할 수 있는 Object 로 정의하기
모든 자바 클래스의 최상위 클래스인 Object 타입으로 필드를 선언한다.   
그러면 Actor 든 Idol 이든 어떤 타입으로도 Goods 클래스를 생성할 수 있다.   

> 심플한 코드 비교   
>   > 위 코드는, 객체수만큼 Goods 클래스(IdolGoods, IdolGoods)도 만들어줘야함. ㅠㅠ   
아래 코드는, 객체수와 상관없이 Goods 클래스 한개(Goods)만 있으면 됨.! 

```java
class Actor {

}

class Idol {

}

// 모든 타입을 저장할 수 있는 굿즈 클래스
class Goods {
    // Object 로 모든 타입의 객체가 저장 가능해진다
    private Object object = new Object();

    public Object getObject() {
        return Object;
    }

    public void setObject(Object object) {
        this.object = object;
    }
}

public class Main {
    public static void main(String[] args) {
        // Goods 를 이용해 Actor 객체 저장(set)하고 가져(get)오기
        Goods goods = new Goods();
        goods.setObject(new Actor());
        Actor actor = (Actor) goods.getObject(); // Object -> Actor 타입 변환

        // Goods 를 이용해 Idol 객체 저장(set)하고 가져(get)오기
        Goods goods = new Goods();
        goods.setObject(new Idol());
        Idol idol = (Idol) goods.getObject(); // Object -> Idol 타입 변환
    }
}
```
이 경우에 주의할 점이 생긴다.!!!  
데이터를 저장할 때는 상관 없지만, 저장된 데이터를 불러올 때 Object 를 각각의 타입 (Actor, Idol) 으로 **다운캐스팅**해야 한다.

```java
public class Main {
    public static void main(String[] args) {
        // ClassCastException 발생 상황
        Goods goods = new Goods();
        goods.setObject(new Idol()); // Idol 객체 저장
        Idol idol = (Actor) goods.getObject(); // Actor 타입으로 캐스팅 
    }
}
```
위와 같이 잘못 캐스팅했을 경우, ClassCastException 예외를 발생시키고 프로그램이 강제 종료될 것이다.   
이를 **'약한 타입 체크'** 라고 한다.
> 약한 타입 체크란, 잘못된 타입 캐스팅에도 문법 오류를 발생시키지 않는 것을 의미한다.

그리고, 위의 ClassCastException 예외 상황을 발생시킬 수 있는 문제를 해결할 수 있는 방법이 **'제네릭'** 이다.!

## 제네릭 문법

제네릭 장점
1. 모든 타입의 상품을 저장할 수 있다.
2. 잘못된 캐스팅을 할 때 문법 오류를 발생시켜 잘못된 캐스팅으로 발생할 수 있는 문제를 사전 예방할 수 있다.

특히, 위의 두번째 장점을 **'강한 타입 체크'** 라고 한다.

### 제네릭 클래스와 제네릭 인터페이스 작성해보기
방법은, 클래스명 다음에 <제네릭 타입 변수(들)> 을 삽입하는 것이다.
```java
public class 클래스명<T> {
    
}

public class 클래스명<K, V> {

}

public interface 클래스명<T> {

}

public interface 클래스명<K, V> {

}
```

**< 제네릭 타입 변수의 관례적 표기 및 의미 >**   
>T = 타입(Type)   
K = 키(Key)   
V = 값(Value)   
N = 숫자(Number)   
E = 원소(Element)  

제네릭 타입 변수명은 임의로 지정할 수는 있지만, 일반적으로 영어 대문자 한글자를 사용하고 위의 관례적 표기법으로 대부분 사용한다.

### 제네릭 클래스의 객체 생성
객체 생성 과정은 일반 클래스와 비슷하나, 클래스명<실제 제네릭 타입> 을 삽입한다는 점에서 차이가 있다.   
객첼츨 생성할 때 제네릭 클래스는 제네릭 타입 변수에 실제 타입을 대입하는 것이다.
```
클래스명<실제 제네릭 타입> 참조변수명 = new 클래스명<실제 제네릭 타입>();

클래스명<실제 제네릭 타입> 참조변수명 = new 클래스명<>(); //오른쪽항의 실제 제네릭 타입은 왼쪽 항과 동일하기 때문에 생략 가능하다
```

### # 제네릭 타입 변수 1개를 가진 제네릭 클래스 예제
```java
class Sports<T> {
    private T t;

    public T getT() {
        return t;
    }

    public void setT(T t) {
        this.t = t;
    }
}

public class Main {
    public static void main(String[] args) {
        // String 타입을 저장 및 관리하는 객체
        Sports<String> sportsStr = new Sports<String>();
        sportsStr.setT("농구");
        
        // Integer 타입을 저장 및 관리하는 객체
        Sports<Integer> sportsInt = new Sports<Integer>();
        sportsInt.setT(1);
        
        // Integer 타입을 저장 및 관리하는 객체
        Sports<Integer> sportsInt = new Sports<Integer>();
        sportsInt.setT("야구"); // 강한 타입 체크로 문법 오류 발생 (Integer 객체에 String 을 담을 수 없음)
    }
}
```
제네릭 클래스는 **클래스를 정의하는 시점에 타입을 지정하는 것이 아니라, 객체를 생성하는 시점에 타입을 지정**한다.   
그렇기 때문에, 하나의 클래스로 다양한 타입의 값을 저장 및 관리할 수 있게 된다.   

### # 제네릭 타입 변수 2개를 가진 제네릭 클래스 예제

```java
class KeyValue<K, V> {
    private K key;
    private V value;

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    public void setKey(K key) {
        this.key = key;
    }

    public void setValue(V value) {
        this.value = value;
    }
}

public class Main {
    public static void main(String[] args) {
        // 스포츠 객체 생성
        KeyValue<Integer, String> sportsKV = new KeyValue<Integer, String>();
        sportsKV.setKey(3);
        sportsKV.setValue("농구");
        
        String sportsCode = sportsKV.getKey(); // sportsCode = 3 출력됨
        int sportsName = sportsKV.getValue(); // sportsName = 농구 출력됨
        
        // 오류 객체 생성
        KeyValue<Integer, String> errorKV = new KeyValue<Integer, String>();
        errorKV.setKey(404); 
        errorKV.setValue("Not Found, 페이지가 없습니다");
        
        // 제네릭 타입 변수의 필요 사용안할 경우 => Void 사용
        KeyValue<Integer, Void> kv = new KeyValue<Integer, Void>();
        kv.setKey("키값만 사용");
        String key = kv.getKey(); // '키값만 사용' 출력됨
    }
}
```
이렇게, 제네릭을 사용하면 위의 Goods 예제에서의 문제점 2개를 해결할 수 있다.   
해결 ① 상품 추가시, 클래스 추가 안해도 됨 => Object 로 해결 가능하지만 ②번은 해결 못함   
해결 ② setter 메서드에 잘못된 객체를 입력했을 경우, 문법 오류 발생시킴

### # 제네릭 클래스를 사용하여 Goods 예제 다시 작성해보기

```java
class Actor {

}

class Idol {

}

class Goods<T> {
    private T t;

    public T getT() {
        return t;
    }

    public void setT(T t) {
        this.t = t;
    }
}

public class Main {
    public static void main(String[] args) {
        // Goods 를 이용해 Actor 객체 저장(set)하고 가져(get)오기
        Goods<Actor> actorGoods = new Goods<>();
        actorGoods.setT(new Actor());
        Actor actor = actorGoods.getT();

        // Goods 를 이용해 Idol 객체 저장(set)하고 가져(get)오기
        Goods<Idol> idolGoods = new Goods<>();
        idolGoods.setT(new Idol());
        Idol idol = idolGoods.getT();
        
        // 오류 발생시키기
        Goods<Actor> actorGoods1 = new Goods<>();
        actorGoods1.setT(new Actor());
        Idol idol1 = actorGoods1.getT(); // 강한 타입 체크로 문법 오류 발생
    }
}
```
참고로, 제네릭 클래스는 객체를 생성할 때 <실제 제네릭 타입> 을 생략해도 문법 오류는 발생하지 않는다.
```java 
A a = new A();   
```

이렇게 위와 같이 작성하면 (아래와 같이) 제네릭 타입 변수에 올 수 있는 최상의 클래스인 Object 가 대입된 것으로 간주한다.   
의미는 동일하다.
```java 
A<Object> a = new A<Object>();
```

## 제네릭 메서드

## 제네릭 타입 범위 제한

## 제네릭 상속