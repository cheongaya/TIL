# 제네릭

## 제네릭 클래스와 인터페이스
자바에서는 클래스와 인터페이스를 내부 멤버에서 활용하는 클래스를 작성하고자 할 때, 
제공되는 클래스나 인터페이스의 다양성 만큼 많은 가짓수의 클래스를 생성해야 한다.

또한, 동일한 이름의 메서드가 다양한 타입의 매개변수를 가질 수 있도록 하기 위해, 고려하는 매개변수 타입의 수만큼 오버로딩을 해야한다.

이런 비효율성을 해결하는데 필요한 문법 요소가 **'제네릭'** 이다.

### 제네릭 없이 여러 객체(배우와 아이돌)를 저장하는 굿즈(Goods) 클래스 작성해보기
클래스 ActorGoods 와 IdolGoods 필드가 Actor 또는 Idol 타입이라는 것을 제외하면 동일하다.   
즉, 배우와 아이돌을 저장하고 관리하기 위해 각각의 동일한 기능을 수행하는 굿즈(Goods) 클래스를 2개 만든 셈이다.

```java
class Actor {

}

class Idol {

}

// 배우만 저장할 수 있는 굿즈 클래스
class ActorGoods {
    private Actor actor = new Actor();

    public Actor getActor() {
        return actor;
    }

    public void setActor(Actor actor) {
        this.actor = actor;
    }
}

// 아이돌만 저장할 수 있는 굿즈 클래스
class IdolGoods {
    private Idol idol = new Idol();

    public Idol getIdol() {
        return idol;
    }

    public void setIdol(Idol idol) {
        this.idol = idol;
    }
}

public class Main {
    public static void main(String[] args) {
        // 배우 저장(set)하고 가져(get)오기
        ActorGoods actorGoods = new ActorGoods();
        actorGoods.setActor(new Actor());
        Actor actor = actorGoods.getActor();

        // 아이돌 저장하고 가져오기
        IdolGoods idolGoods = new IdolGoods();
        idolGoods.setIdol(new Idol());
        Idol idol = idolGoods.getIdol();
    }
}
```
위와 같이 설계를 한다면, 새로운 상품이 추가될 떄마다 ActorGoods, IdolGoods 과 같은 클래스를 생성해야는 문제가 발생한다.   

### # 문제 정의 : 1개의 굿즈 클래스로 모든 타입의 상품을 저장하고 관리할 수는 없을까??

### 해결 ① 필드타입을 모든 객체를 저장할 수 있는 Object 로 정의하기
모든 자바 클래스의 최상위 클래스인 Object 타입으로 필드를 선언한다.   
그러면 Actor 든 Idol 이든 어떤 타입으로도 Goods 클래스를 생성할 수 있다.   

> 심플한 코드 비교   
>   > 위 코드는, 객체수만큼 Goods 클래스(IdolGoods, IdolGoods)도 만들어줘야함. ㅠㅠ   
아래 코드는, 객체수와 상관없이 Goods 클래스 한개(Goods)만 있으면 됨.! 

```java
class Actor {

}

class Idol {

}

// 모든 타입을 저장할 수 있는 굿즈 클래스
class Goods {
    // Object 로 모든 타입의 객체가 저장 가능해진다
    private Object object = new Object();

    public Object getObject() {
        return Object;
    }

    public void setObject(Object object) {
        this.object = object;
    }
}

public class Main {
    public static void main(String[] args) {
        // Goods 를 이용해 Actor 객체 저장(set)하고 가져(get)오기
        Goods goods = new Goods();
        goods.setObject(new Actor());
        Actor actor = (Actor) goods.getObject(); // Object -> Actor 타입 변환

        // Goods 를 이용해 Idol 객체 저장(set)하고 가져(get)오기
        Goods goods = new Goods();
        goods.setObject(new Idol());
        Idol idol = (Idol) goods.getObject(); // Object -> Idol 타입 변환
    }
}
```
이 경우에 주의할 점이 생긴다.!!!  
데이터를 저장할 때는 상관 없지만, 저장된 데이터를 불러올 때 Object 를 각각의 타입 (Actor, Idol) 으로 **다운캐스팅**해야 한다.

```java
public class Main {
    public static void main(String[] args) {
        // ClassCastException 발생 상황
        Goods goods = new Goods();
        goods.setObject(new Idol()); // Idol 객체 저장
        Idol idol = (Actor) goods.getObject(); // Actor 타입으로 캐스팅 
    }
}
```
위와 같이 잘못 캐스팅했을 경우, ClassCastException 예외를 발생시키고 프로그램이 강제 종료될 것이다.   
이를 **'약한 타입 체크'** 라고 한다.
> 약한 타입 체크란, 잘못된 타입 캐스팅에도 문법 오류를 발생시키지 않는 것을 의미한다.

그리고, 위의 ClassCastException 예외 상황을 발생시킬 수 있는 문제를 해결할 수 있는 방법이 **'제네릭'** 이다.!

## 제네릭 문법

## 제네릭 메서드

## 제네릭 타입 범위 제한

## 제네릭 상속